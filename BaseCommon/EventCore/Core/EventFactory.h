//-------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : tEventFactory.h
//  @ Date : 2011-5-18
//  @ Author : 杨文鸽
// 事件驱动系统
// 对于数据：表头采用共享方式，但如果一旦被修改，将被重建，不过不会影响
// 修改之前的记录数据使用
//-------------------------------------------------------------------


#if !defined(_TEVENTFACTORY_H)
#define _TEVENTFACTORY_H

#include "EventCore.h"
//#include "NiceTable.h"
#include "Event.h"
#include "EasyList.h"

#include "EasyStack.h"
#include "NiceDataProtocol.h"

#define REGISTER_EVENT(center, eventClass)	 center->RegisterEvent(#eventClass, MEM_NEW Logic::EventFactory<eventClass, true>());
#define REGISTER_MSG_EVENT(center, msgName) center->RegisterEvent(msgName, MEM_NEW Logic::EventFactory< Logic::tBaseNetEvent, true>());
#define EX_REGISTER_EVENT(center, eventName, eventClass)	 center->RegisterEvent(eventName, MEM_NEW Logic::EventFactory<eventClass, true>());
//-------------------------------------------------------------------------
// NOTE: 消息包序列时,占用4BIT作为长度, 所以最多只能使用4位, 详见 EventNetProtocol::WritePacket
enum EEventPacketState
{
	ePacketStateEncrypt	= 1,				// 需要加密
	ePacketStateZip			= 1<<1,		// 是否压缩
	eEventDataPacket		= 1<<2,		// 事件数据包，用于从接收流中直接读取恢复事件数据
    eFactoryNoProtocolSave = 1<<3,  // 保存序列事件时不使用协议方式
	eNeedLog = 1<<4,
	eReleased = 1<<5,							// 已经释放状态
};
//-------------------------------------------------------------------------*/
namespace Logic
{
	class tEventCenter;
	typedef AutoTable FactoryTable;
	class tEventFactory;
	class tServerEvent;
	//----------------------------------------------------------------
	class EventCoreDll_Export tEventFactory : public Base<tEventFactory>
	{
	public:
		typedef EasyMap<int, AString>	SelectDataMap;

	public:
		friend class tEvent;
		friend class CEvent;
		friend class tEventCenter;
		friend class EventCenter;
		friend class BaseEvent;		
		friend class CEventFactory;

		void Release();
		virtual void OnForceFreeBefore() override;
		virtual void ReaydyListNodePool( AutoPtr<NodePool>  hPool) = 0;

	public:
		tEventCenter* GetEventCenter(void)const{ return (tEventCenter*)mCenterPtr->mpObject; }
		void OnRemove();

	public:
		tEventFactory();
		virtual ~tEventFactory();

	public:
		virtual void Initialize(void){}
        virtual int GetID() const { return mID; }
        virtual void SetID(int id){ mID = id; } 
		virtual int GetNameIndex(void){ return mNameIndex; }
		virtual const char* GetEventName(void) const { return mEventName.c_str(); }
        virtual void SetEventName(const char* strEventName);

		virtual AString GetNextEventName(void){ return AString(); }
		virtual NiceData& GetData(void) = 0;
		virtual void SetConfigTable(AutoTable hTable) = 0;
		virtual AutoTable GetConfigTable(void) const = 0;
		virtual const AutoEvent& GetTemplate(void)const = 0;

		virtual void _SetHelpTable(AutoTable helpTable) = 0;
		virtual AutoTable _GetHelpTable() const = 0;

		virtual SelectDataMap& GetSelectData(void) = 0;
		virtual void AppendSelectData(const char* indexName) = 0;
		virtual bool RemoveSelectData(const char* indexName) = 0;

		virtual void SetState(int nState, bool bOpen) = 0;
		virtual bool HasState(int state) = 0;

		//virtual void SetDataProtocol(ANiceDataProtocol protocol){}
		//virtual ANiceDataProtocol& GetDataProtocol(){ static ANiceDataProtocol p; return p; }

		virtual AutoEvent NewEvent() = 0; 

	protected:
		virtual void FreeEvent(tEvent *event);
		virtual bool _HasRelation(AutoEvent &hEvent) { return false; }
		virtual bool SaveEventName(DataStream *destData);
		virtual bool SaveEventNameIndex(DataStream *destData);


	public:		
		virtual AutoEvent StartEvent(void);

		virtual void _OnEvent(AutoEvent &hEvent) = 0;
		virtual bool _NeedWaitTrigger(void) = 0;
		virtual void _OnWaitEvent(AutoEvent hEvent) = 0; 
		virtual void _RemoveWaitEvent(EVENT_ID) = 0;

		virtual void _NodifyEventFinish(AutoEvent hEvent) = 0;

		virtual void AppendTriggerEventName(const char* strEventName){}
		virtual void RemoveTriggerEventName(const char* strEventName){}

		virtual void AllotEventID(tServerEvent *serverEvent){}
		virtual void FreeServerEvent( tServerEvent *serverEvent ){}

        virtual int GetNiceDataProtocolKey(){ return mNiceProtocol ? mNiceProtocol->GetField()->GetCheckCode() : 0; }

	public:
		virtual void Process(void *param) = 0;

#if SHOW_EVENT_TICK
		int				mCount;				// 调用数次
		UInt64			mStartTick;			// 开始调用时间
		int				mAverageTick;		// 平均调用时间
#endif

	protected:
		AObjectPtr	mCenterPtr;
		AString			mEventName;
		int				mNameIndex;
		int				mID;
        AutoTable   mNiceProtocol;
        DataBuffer   mNiceProtocolData;
		EasyStack<tEvent*>	mFreeEventPool;		
		PoolList<tEvent*>		mAllEventList;
	};

	//----------------------------------------------------------------

	//----------------------------------------------------------------
	typedef Hand<tEventFactory>				AutoEventFactory;
	typedef Array<AutoEventFactory>			EventFactoryArray;

	// 确发事件工厂, 将要确发的事件在获取时, 就被加入到等待确发的列表中, 直到事件执行了Finish
	class EventCoreDll_Export CEventFactory : public tEventFactory
	{
	public:
		CEventFactory();
		virtual ~CEventFactory();

	public:
		virtual void ReaydyListNodePool( AutoPtr<NodePool> hPool);

		virtual void SetConfigTable(AutoTable hTable);
		virtual AutoTable GetConfigTable(void) const;
		virtual NiceData& GetData(void){ return mConfigData;}
		const AutoEvent& GetTemplate(void) const { return mTemplateEvent; }
		virtual AString GetNextEventName(void){ return AString(); }

		virtual void _SetHelpTable(AutoTable helpTable);
		virtual AutoTable _GetHelpTable() const;

		virtual SelectDataMap& GetSelectData(void) { return mSelectData; }
		virtual void AppendSelectData(const char* indexName){ mSelectData.insert(MAKE_INDEX_ID(indexName), AString(indexName)); }
		virtual bool RemoveSelectData(const char* indexName) { return mSelectData.erase(MAKE_INDEX_ID(indexName))>0; };
		
	public:
		virtual void Initialize( void );

		virtual bool _NeedWaitTrigger(void){ return false; }
		virtual void _OnWaitEvent(AutoEvent hEvent); 
		virtual void _RemoveWaitEvent(EVENT_ID) {}

		virtual void _NodifyEventFinish(AutoEvent hEvent);

		virtual void _OnEvent(AutoEvent &hEvent);

		void RemoveTriggerEvent(AutoEvent &event);

		virtual void AppendTriggerEventName(const char* strEventName);
		virtual void RemoveTriggerEventName(const char* strEventName);
		//使用关系事件列表来判断是否与指定事件有关系
		virtual bool _HasRelation(AutoEvent &hEvent);

		bool _ExistTriggerEventList(const char* eventName);
		// NOTE: 当前事件中心已停止此功能的调用
		virtual void Process(void *param);

	public:
		virtual void SetState(int nState, bool bOpen) { mState.set(nState, bOpen); }
		virtual bool HasState(int state) { return mState.isOpen(state); }

		//virtual void SetDataProtocol(ANiceDataProtocol protocol){mDataProtocol = protocol; }
		//virtual ANiceDataProtocol& GetDataProtocol(){ return mDataProtocol; }

	protected:
		StateData					mState;
		mutable bool			mNeedRemove;
		mutable NiceData	mConfigData;
		EventList					mTriggerEventList;
		EasyMap<int, AString>	mTriggerEventNameMap;
		SelectDataMap		mSelectData;
		AutoTable				mHelpTable;

		//ANiceDataProtocol		mDataProtocol;

		AutoEvent				mTemplateEvent; // 支持多线

	public:
		virtual void SetOnBeginFunName(const char* funName){  }
		virtual const AString& GetOnBeginFunName(void) const { static AString tempName; return tempName; }
		virtual void SetDoEventFunName(const char* funName){  }
		virtual const AString& GetDoEventFunName(void) const { static AString tempName; return tempName; }
		virtual void SetOnEventScriptFunName(const char* strFunName){ }
		virtual const AString& GetOnEventFunName(void)const { static AString tempName; return tempName; }
		virtual void SetOnFinishFunName(const char* funName){  }
		virtual const AString& GetOnFinishFunName(void) const {static AString tempName; return tempName; }

		// for Logic node
		virtual void SetNextLogicFunName(const char* funName){ }
		virtual const AString& GetNextLogicFunName(void) const { static AString tempName; return tempName; }
		// for Logic event
		virtual void SetBeginLogicName(const char* logicName){  }
		virtual const AString& GetBeginLogicName()const{ static AString tempName; return tempName; }

	};
	//----------------------------------------------------------------

	template<typename E, bool bLog = false>
	class EventFactory : public Logic::CEventFactory
	{
		virtual AutoEvent NewEvent()
		{
			AutoEvent hEvt = MEM_NEW E();
			
			return hEvt;
		}

	public:
		EventFactory(bool bEncrypt = true)
		{
			SetState(ePacketStateEncrypt, bEncrypt);
			SetState(eNeedLog, bLog);
		}
	};
	//-------------------------------------------------------------------------
}


#ifndef STATE_EVENTCORE_LIB

template<>
void Hand<Logic::tEventFactory>::FreeClass(Logic::tEventFactory *p)
{
	p->Release();
}
template<>
void Hand<Logic::tEventFactory>::FreeUse()
{
	mUse->Release();
}
#endif

#endif  //_TEVENTFACTORY_H
