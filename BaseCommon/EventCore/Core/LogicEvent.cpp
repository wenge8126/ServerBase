//----------------------------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : BaseLogicEvent.cpp
//  @ Date : 2011-5-25
//  @ Author : 杨文鸽
//
//----------------------------------------------------------------------------------------


#include "LogicEvent.h"

#include "LogicNode.h"
#include "EventCenter.h"

namespace Logic
{
	//-----------------------------------------------------------------------------
 
	bool LogicEvent::_DoEvent()
	{
		const char* beginLogicName = GetBeginLogicName();
		if (NULL==beginLogicName)
		{
			Log("Error: not set Logic control event name [Logic]");
			return false;
		}
		AutoEvent hE = GetEventCenter()->StartEvent(beginLogicName);
		if (!hE)
		{
			Log("Error: no exist [%s] Logic control event", beginLogicName);
			return false;
		}
		if (NULL==dynamic_cast<tLogicNode*>(hE.getPtr()))
		{
			Log("Error: event [%s] is not Logic control event[tLogicNode]", beginLogicName);
			return false;
		}
		return StartLogic(hE);
	}
	//-----------------------------------------------------------------------------

	bool LogicEvent::StartLogic( AutoEvent hLogic )
	{
		if (!hLogic)
		{
			Log("错误: 未正常启动下一步逻辑-->指定逻辑为空!");
			return false;
		}
		tLogicNode *pLogic = dynamic_cast<tLogicNode*>(hLogic.getPtr());
		if (NULL==pLogic)
		{
			Log("Error: set current logic fail, param logic [%s] event is not logic node [tLogicNode] type", hLogic->GetEventName());
			return false;
		}

		Log("成功开启下一步逻辑[%s]", hLogic->GetEventNameInfo().c_str());
//#if SAVE_DEBUG_INFO
//		CEvent *pEvt = dynamic_cast<CEvent*>(hLogic.getPtr());
//		pEvt->_MakeLinkInfo(GetSelf());
//		for (EasyList<AString>::iterator hit=pLogic->GetLogicFactory()->getEventList().begin(); hit!=pLogic->GetLogicFactory()->getEventList().end(); ++hit)
//		{
//			pEvt->mEventLinkInfo += "<";
//			pEvt->mEventLinkInfo += (*hit).c_str();
//			pEvt->mEventLinkInfo += ">";						
//		}
//#endif

		mCurrentLogic = hLogic;
		pLogic->setMainLogic(GetMainLogic());
		pLogic->setParentLogic(mSelf);
		pLogic->Log("由LogicEvent[%s]开始启动...", GetEventNameInfo().c_str());
		pLogic->Dump();
		//mCurrentLogic->Wait();
		mCurrentLogic->Begin();
		mCurrentLogic->DoEvent(false);
		return true;
	}
	//-----------------------------------------------------------------------------

	void LogicEvent::_OnFinish()
	{		
		
		//AutoEvent parentLogic;
		//if (get("PARENT_LOGIC", &parentLogic, typeid(AutoEvent)))
		//{
		//	tLogicNode *pLogic = dynamic_cast<tLogicNode*>(parentLogic.getPtr());
		//	if (pLogic)
		//	{
		//		pLogic->mEventLinkInfo += "{子逻辑:";
		//		pLogic->mEventLinkInfo += _GetLinkInfo().c_str();
		//		pLogic->mEventLinkInfo += "}";
		//		INFO_LOG("逻辑流程:%s", pLogic->_GetLinkInfo().c_str());
		//		bLog = true;
		//	}
		//}

		//if (!bLog)
		//	INFO_LOG("逻辑流程:%s", _GetLinkInfo().c_str());
	}

	const char* LogicEvent::GetBeginLogicName( void )
	{
		const LogicEventFactory *pF = dynamic_cast<const LogicEventFactory*>( GetEventFactory().getPtr() );
		if (pF)
			return pF->GetBeginLogicName().c_str();
		else
			Log("Error: this event factory is not [LogicEventFactory] type");
		return "";
	}

	void LogicEvent::_OnBegin()
	{

	}

	void LogicEvent::SetMainLogic( AutoEvent mainLogic )
	{
		set("MainLogic", mainLogic);
	}

	AutoEvent LogicEvent::GetMainLogic( void )
	{
		AutoEvent hE;
		if (get("MainLogic", hE))
		{
			return hE;
		}
		else
			return GetSelf();
	}

	void LogicEvent::_OnEventFinishNodify( AutoEvent event )
	{
		AutoEvent currentEvent;
		get(CURRENT_LOGIC_NODE, currentEvent);
		if (!currentEvent || currentEvent==event)
		{
			Log("&&&&&&&&&&&&&&&&&&&&&&&&&&&&& [%s]使当前[%s]结束, Info: to finish this", event->GetEventNameInfo().c_str(), GetEventNameInfo().c_str());
			event->GetData().dump();
			Finish();
			mCurrentLogic.setNull();
		}
	}

	//-----------------------------------------------------------------------------


}