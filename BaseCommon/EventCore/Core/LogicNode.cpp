//----------------------------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : BaseLogicEvent.cpp
//  @ Date : 2011-5-25
//  @ Author : 杨文鸽
//
//----------------------------------------------------------------------------------------


#include "LogicNode.h"
#include "EventCenter.h"
#include "ScriptFace.h"
#include "LogicEvent.h"
//-----------------------------------------------------------------------------

class TotalDebug
{
public:
	TotalDebug()
	{

	}
	~TotalDebug()
	{
		int b = (int)mLogicList.size();
		for (EasyList<Logic::tLogicNode*>::iterator it=mLogicList.begin(); it; ++it)
		{
			//(*it)->GetData().dump();
		}
	}

	void OnNewLogic(Logic::tLogicNode *logic)
	{
		mLogicList.insert(logic);
	}

	void OnFreeLogic(Logic::tLogicNode *logic)
	{
		for (EasyList<Logic::tLogicNode*>::iterator it=mLogicList.begin(); it; ++it)
		{
			if ((*it)==logic)
			{
				mLogicList.erase(it);
				return;
			}
		}
	}

public:
	EasyList<Logic::tLogicNode*>	mLogicList;

};

TotalDebug		gTotalDebug;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

namespace Logic
{
	tLogicNode::tLogicNode()
	{
		gTotalDebug.OnNewLogic(this);
	}
	//-----------------------------------------------------------------------------

	tLogicNode::~tLogicNode()
	{
		//强行释放自身保存的所有的逻辑节点，因为逻辑节点相互保存，造成在未完成的情况下释放死锁
		gTotalDebug.OnFreeLogic(this);
	}
	//-----------------------------------------------------------------------------

	AutoEvent tLogicNode::NextAction()
	{
		EasyList<AString> &eventList = GetLogicFactory()->getNextActionList();
		for (EasyList<AString>::iterator it=eventList.begin(); it; ++it)
		{
			AString &str = (*it);
			AutoEvent evt = StartEvent( str.c_str() );
			if (evt)
			{
				tLogicNode *p = dynamic_cast<tLogicNode*>(evt.getPtr());
				if (p)
				{
					if (p->canRun(getMainLogic()))
						return evt;
				}
			}
			else
			{

				Log("Error:  next logic node event is not exist [%s]." , str.c_str());
			}
		}
		return AutoEvent();
	}
	//-----------------------------------------------------------------------------

	bool tLogicNode::_DoEvent( void )
	{
		EasyList<AString> &eventList = GetLogicFactory()->getEventList();
		for (EasyList<AString>::iterator it=eventList.begin(); it; ++it)
		{
			AutoEvent evt = StartEvent( (*it).c_str() );
			if (evt)
			{
				mEventList.insert(evt);
				tLogicNode *pNode = dynamic_cast<tLogicNode*>(evt.getPtr());
				if (pNode)
				{
					evt->set(PARENT_NODE_KEY, evt); 
					evt->set(CURRENT_LOGIC_NODE, evt);
				}
				AutoEvent hMain = getMainLogic();
				evt->set(MAIN_DATA_KEY, hMain);
				evt->set("FINISH_NOTIFY", mSelf);

				evt->Begin();
				evt->DoEvent(false);
				evt->Log("被[%s]开始执行...", GetEventNameInfo().c_str());
				evt->Dump();
			}
		}
		// 节点当作事件附加到逻辑节点情况
		// 分支的情况时, 自己分支的开始位置应该写在这里
		// 也就是说,自身的支线是开始节点
		if (getParentLogic()==mSelf)
		{
			//StartBeginLogic(NULL);
			AutoEvent next = NextAction();
			if (next)
			{
				startNextLogic(next); 
			}
		}

		return true;
	}

	LogicNodeFactory* tLogicNode::GetLogicFactory( void )
	{
		LogicNodeFactory *f = dynamic_cast<LogicNodeFactory*>((tEventFactory*)GetEventFactory().getPtr());
		if (NULL==f)
		{
			AString info = "Error: LogicNodeFactory is null, need use logic event factory template. event ";
			info += GetEventName();
			Log(info.c_str());
#ifdef __LINUX__
			throw 1;
#else
            throw std::exception(info.c_str());
#endif
		}
		return f;
	}

	void tLogicNode::_OnFinish( void )
	{
		// Log("####################  处理结束中...");
		if (getParentLogic()  && !getParentLogic()->getFinished())
		{		
			// 注意： 这里，如果是脚本节点执行，返回一般都没有下一节点
			if (getParentLogic()!=mSelf)
			{		
				AutoEvent next = NextAction();
				if (next) 
				{
					startNextLogic(next); 
				}
			}
		}
	}
	//-----------------------------------------------------------------------------

	void tLogicNode::_OnEventFinishNodify( AutoEvent event )
	{
		if (!mEventList.remove(event))
		{
			if (event==getCurrentLogic()) 
			{
				setCurrentLogic(AutoEvent());
			}
			else 
			{
				// 这个地方可能执行不到
				AutoEvent mBeginNode;
				if ( get("BeginNode", mBeginNode) && mBeginNode==event )
				{
					Log("开始逻辑节点完成[%s]", event->GetEventNameInfo().c_str());
					GetData().remove("BeginNode");
				}
			}
		}
		if (CheckFinish())
			Finish();
	}
	//-----------------------------------------------------------------------------

	void tLogicNode::startNextLogic( AutoEvent &hLogic )
	{
		tLogicNode *pNode = dynamic_cast<tLogicNode*>(hLogic.getPtr());
		if (NULL==pNode)
		{
			Log("Warning: [%s] is not tLogicNode event, now default");
			hLogic->set(PARENT_NODE_KEY, getParentLogic());
			hLogic->set("MainLogic", getMainLogic());
		}
		else
		{
			pNode->setMainLogic(getMainLogic());
			pNode->setParentLogic(getParentLogic());
			pNode->Log("$$$$$$$$$---> 被 [%s] 成功执行", GetEventNameInfo().c_str());
		}
		hLogic->Begin();
		hLogic->DoEvent(false);
		setCurrentLogic(hLogic);
	}

	//-----------------------------------------------------------------------------

	AutoEvent tLogicNode::startNextLogic( const char* nextLogicName )
	{
		AutoEvent hNext = StartEvent(nextLogicName);
		if (hNext)
			startNextLogic(hNext);
		else
			Log("Error: next logic [] no exsit", nextLogicName);
		return hNext;
	}
	//-----------------------------------------------------------------------------
	void tLogicNode::_OnBegin()
	{
		CEvent::_OnBegin();

		
	}
	//-----------------------------------------------------------------------------
	bool tLogicNode::CheckFinish()
	{
		// 1 当前可否完成,用于脚本控制
		// 2 EventList 是附加的事件是否全部完成,完成后会从这个列表中移除
		// 3 当前逻辑是否为空
		// 4 当前逻辑节点是否就是自己, 这种情况是在等待附加事件完成之后
		// 5 当具支线逻辑时,支线逻辑也要完成, 在begin时开启
		AutoEvent hE = getCurrentLogic();
		AString logicName;
		if (hE)
			logicName = hE->GetEventNameInfo().c_str();
		else
			logicName = "NULL";
		Log("当前事件[%s], 当前逻辑节点[%s]", GetEventNameInfo().c_str(), logicName.c_str());
		return (_currentCanFinish()
			&& !existData("BeginNode")
			&& mEventList.empty()
			&& (!getCurrentLogic() || getCurrentLogic()==mSelf)
			);
	}
	//-----------------------------------------------------------------------------
	
	void tLogicNode::setMainLogic( AutoEvent mainLogic )
	{
		set(MAIN_DATA_KEY, mainLogic);
	}
	//-----------------------------------------------------------------------------

	AutoEvent tLogicNode::getMainLogic( void )
	{
		AutoEvent mainData;
		if (!get(MAIN_DATA_KEY, mainData))
		{
			Log("Error: get main logic fail, no set [MainLogic],so this is data event, no set self is main data event");
			set(MAIN_DATA_KEY, mSelf);
			return mSelf;
		}
		return mainData;

	}

	void tLogicNode::setParentLogic( AutoEvent hParent )
	{
		set(PARENT_NODE_KEY, hParent);
	}

	AutoEvent tLogicNode::getParentLogic( void )
	{
		AutoEvent hE;
		if (!get(PARENT_NODE_KEY, hE))
		{
			Log("Info: get parent logic event [LOGIC_CONTROL] no exsit, now this is parent");
			return mSelf;
		}
		return hE;
	}

	void tLogicNode::setCurrentLogic( AutoEvent hLogic )
	{
		AutoEvent hE = getParentLogic();
		if (hE)
		{
			// 先强行终止当前正在运行的节点
			AutoEvent currentLogic;
			if (hE->get(CURRENT_LOGIC_NODE, currentLogic))
			{
				currentLogic->setFinished(true);
				currentLogic->Free();
			}
			hE->set(CURRENT_LOGIC_NODE, hLogic);
		}
		else
			Log("错误: 未能得到父节点");
	}

	AutoEvent tLogicNode::getCurrentLogic( void )
	{
		AutoEvent hE = getParentLogic();
		AutoEvent currentLogic;
		if (hE)
			hE->get(CURRENT_LOGIC_NODE, currentLogic);
		else
			Log("Warning : 当前还不存在逻辑");
		return currentLogic;
	}

	void tLogicNode::StartBeginLogic( const char* beginLogicName )
	{
		AutoEvent mBeginLogic = GetEventCenter()->StartEvent(beginLogicName);			
		if (mBeginLogic)
		{
			mBeginLogic->set(PARENT_NODE_KEY, mBeginLogic);
			//mBeginLogic->set("FINISH_NOTIFY", mSelf);
			mBeginLogic->set(MAIN_DATA_KEY, getMainLogic());
			Log("成功开启支线逻辑[%s]", mBeginLogic->GetEventNameInfo().c_str());
			mBeginLogic->Begin();
			mBeginLogic->DoEvent(false);
			set("BeginNode", mBeginLogic);
		}
	}


	//-----------------------------------------------------------------------------

}