//----------------------------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : BaseLogicEvent.h
//  @ Date : 2011-5-25
//  @ Author : 杨文鸽
//	控制逻辑节点
//----------------------------------------------------------------------------------------


#if !defined(_LOGICCONTROL_H)
#define _LOGICCONTROL_H

#include "CEvent.h"
#include "EventCore.h"

#define PARENT_NODE_KEY		"LOGIC_CONTROL"
#define MAIN_DATA_KEY		"MainLogic"
#define CURRENT_LOGIC_NODE	"CurrentLogic"

#define CURRENT_CAN_FINISH	"_CanFinish"

namespace Logic
{
	class LogicNodeFactory;
	//-----------------------------------------------------------------------------
	// 1 执行事件
	// 2 执行附加的事件
	// 3 自身完成后执行下一步逻辑节点, 下一步可以直接指定,也可在脚本中执行
	// 4 为了支持支线逻辑, 第一个执行的节点,代表一个逻辑支线, 可以附加到另外的逻辑节点中选择执行,
	//	 一般执行时初始准备数据, 然后就会直接执行下一条逻辑, 只有整个下面的支线全部完成才能完成
	// 5 完成条件 1 自己执行OK 2 附加事件全执行OK 3以下的支线全部完成
	// 6 无当前逻辑,即是一般节点时,1 2都完成后即可以完成
	//-----------------------------------------------------------------------------

	class EventCoreDll_Export tLogicNode : public CEvent
	{
	public:
		tLogicNode();
		~tLogicNode();

	public:
		// 事件部分
		virtual bool _AutoFinish() { return false; }

		// 开始逻辑,执行节点中的所有事件
		virtual void _OnBegin();

		// 执行当前状态所有的行为
		virtual bool _DoEvent(void);
		// 主要启动分析下一步
		virtual void _OnFinish(void);
		// 分析是否当前的事件全部执行完毕,默认全部执行完后,才进行完成操作
		virtual void _OnEventFinishNodify(AutoEvent event);

	public:
		// 节点部分
		// 设定下一个行为节点
		virtual AutoEvent NextAction();
		virtual bool CheckFinish();

		// 启动下一个逻辑, 强行终止当前节点
		virtual void startNextLogic(AutoEvent &hLogic);
		virtual AutoEvent startNextLogic(const char* nextLogicName);

		virtual void StartBeginLogic( const char* beginLogicName );

		virtual void setMainLogic(AutoEvent mainLogic);
		virtual AutoEvent getMainLogic(void);

		virtual void setParentLogic(AutoEvent hParent);
		virtual AutoEvent getParentLogic(void);

		virtual void setCurrentLogic(AutoEvent hLogic);

		// 获取逻辑支线中, 当前正在执行的逻辑节点
		virtual AutoEvent getCurrentLogic(void);

		virtual bool _currentCanFinish(void){ return true; }

		virtual bool canRun(AutoEvent nextLogic){ return true; }

	public:
		LogicNodeFactory* GetLogicFactory(void);

	protected:
		EasyList<AutoEvent>		mEventList;

	};
	//-----------------------------------------------------------------------------

	typedef Hand<tLogicNode>	AutoLogic;
	//-----------------------------------------------------------------------------

	class EventCoreDll_Export LogicNodeFactory : public CEventFactory
	{
	public:
		void addEvent(const char* actionEventName){ mEventList.insert(AString(actionEventName)); }
		void addNextLogic(const char* nextLogic){ mNextEvent.insert(AString(nextLogic)); }

		void removeEvent(const char* actionEventName){ mEventList.remove(AString(actionEventName)); }
		void removeNextLogic(const char* nextLogic){ mNextEvent.remove(AString(nextLogic)); }

		EasyList<AString>& getEventList(void){ return mEventList; }
		EasyList<AString>& getNextActionList(void){ return mNextEvent; }

	protected:
		EasyList<AString>	mNextEvent;
		EasyList<AString>	mEventList;
	};

	template<typename T>
	class DefineLogicFactory : public LogicNodeFactory
	{
	public:
		DefineLogicFactory( const char* nextLogicName )
		{
			addNextLogic(nextLogicName);
		}

		virtual AutoEvent NewEvent(void){ return MEM_NEW T(); }
	};

}

#endif  //_LOGICCONTROL_H
