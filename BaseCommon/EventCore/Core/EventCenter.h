//-------------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : tEventCenter.h
//  @ Date : 2011-5-18
//  @ Author : 杨文鸽
//	事件驱动模型
//-------------------------------------------------------------------------


#ifndef _TEVENTCENTER_H
#define _TEVENTCENTER_H

#include "EventCore.h"
#include "Event.h"
#include "EventFactory.h"
#include "EasyMap.h"
#include "EasyList.h"
#include "PoolLoop.h"
#include "AutoString.h"
#include "NetHandle.h"
#include "AutoKey.h"
#include "EventCallBack.h"
#include "ArrayIndex.h"
#include "DataProtocol.h"
#include <string>

//using namespace stdext;
//-----------------------------------------------------------------------------------
namespace LuaPlus
{
	class LuaObject;
}

class tNetHandle;
namespace Logic
{

	typedef EasyHash<AString, AutoEventFactory>	EventFactoryMap;	

	class tEventThreadServer;
	class tScriptFace;
	class tEventCenterManager;
	class FixedTimeManager;

	class EventCoreDll_Export tEventCenter : public Base<tEventCenter>
	{
		friend class CEventFactory;
		friend class tEvent;

	public:
		tEventCenter();

		virtual void Release() override;
		virtual void OnForceFreeBefore() override { ProcessWaitEvent(); RemoveAllFactory(); }

#ifndef __LINUX__
	protected:
#else
    public:
#endif
		virtual ~tEventCenter();

	public:
		//AutoEventFactory _GetEventFactory(int nameIndexID);
		AutoEventFactory _GetEventFactory(const char* eventName);
		bool _ExistEventFactory(const char* eventName);
		FixedTimeManager* GetTimeEventManager(){ return mFixedTimeManager; }
		EventFactoryMap& GetFactoryMap(){ return mFactoryMap; }
		AutoEventFactory GetEventFactoryByNameIndex(int nameIndex){ return mFactoryArray.find(nameIndex); }		

	public:
		virtual bool _StartWaitTime(AutoEvent waitEvent, float waitSecond);
		virtual bool _StartUpdateEvent(AutoEvent updateEvent, float spaceSecond);
		virtual void _NodifyEventFinish(AutoEvent hEvent);

	public:
		virtual void _SetEventThreadServer(tEventThreadServer *eventThreadMgr){}
		virtual tEventThreadServer* _GetEventThreadServer(void){ return NULL; }
		virtual void _SetScriptFace(tScriptFace *pFace){ }
		virtual tScriptFace* _GetScriptFace(){ return NULL; }
		virtual void _SetEnvironmentID(int id){ mEnvironmentID = id; }
		virtual int _GetEnvironmentID(void){ return mEnvironmentID; }
		
		virtual void _SetNetTool(int nType, AutoNet netTool){};
		virtual AutoNet _GetNetTool(int nType){ return AutoNet(); }

		virtual AutoPtr<NodePool> GetEventNodePool(void){ return mShareListPool; }

		virtual void* getOrMakeLuaEventObject(AutoEvent &hEvent){ return NULL; }

		virtual AutoEventFactory GetResponseEventFactory()
		{
			AssertEx(mResponseEventFactory, "回复事件未注册");
			return mResponseEventFactory; 
		}

	public:
		//virtual bool SendEvent(AutoEvent &event, int nNetType = 0, int nTarget = 0) = 0; 

		// 更新消息反序列时用到的索引， 被动更新的索引用于反序列， 注册时生成的索引用于序列
		// 为了同一事件中心同时使用在服务及连接中，如网络节点中
		virtual void UpdateNetMsgIndex(AutoData msgIndexData);

		// 生成消息事件索引数据，msgNameIndex = 0 表示生成所有的
		virtual bool GenerateMsgIndex(AutoData &destData, int msgNameIndex = 0);

	public:
		virtual AutoEvent StartEvent(const char* strEventName);
		virtual AutoEvent StartEvent(const AString &strEventName);
		virtual AutoEvent StartEvent(int nEventNameIndex);
		virtual AutoEvent StartEvent(const char* strEventName, bool bWarn);

		virtual void ProcessEvent();
		virtual void ProcessWaitEvent();

		virtual AutoEvent StartDefaultEvent( const char* eventName ) = 0;
		virtual AutoEventFactory RegisterDefaultEvent(const char* szEventName) = 0;
		virtual KEY_TYPE AutoAlloctKey() = 0;
		
		AutoEvent WaitTime( float fSecond, EventCallBack callBack );
		AutoEvent WaitUpdate(float fSpaceTime, EventCallBack callBack);

		virtual void StopWaitTimeEvent(AutoEvent evt);
		virtual void StopUpdateEvent(AutoEvent evt);

		virtual void PauseEvent(AutoEvent hEvent);
		virtual void ContinueEvent(AutoEvent hEvent);

		void Waiting(AutoEvent event);
		void FreeEvent(AutoEvent event) { mFreeEventList.insert(event); }

		void RegisterEvent(const char* strEventName, AutoEventFactory hFactory);
		void RegisterEvent(const AString &strEventName, AutoEventFactory hFactory);
		
		void RegisterFinish(float optimizeRate = 10.5f)
		{
			mFactoryMap.OptimizeSpeed(10.5f);
			mFactoryArray.OptimizeSpeed(10.5f);
		}

		bool RemoveFactory(const char* eventName);
		virtual void RemoveAllFactory(void);

		void SetTrigger(const char* triggerEventName, const char* actionEventName);
		void RemoveTrigger(const char* triggerEventName, const char* actionEventName);

	public:
		virtual bool  SerializeEvent(AutoEvent &hEvent, DataStream *destData);
		virtual AutoEvent RestoreEvent(DataStream *scrData);

		virtual bool  SerializeMsg(AutoEvent &hEvent, DataStream *destData);
		virtual AutoEvent RestoreMsg(DataStream *scrData);

		virtual bool ComeOnThread(AutoEvent &hEvent)
		{
#ifndef __LINUX__
			throw std::exception( "Error: use not finish function on call ComeOnThread.");
#endif
		}

		virtual void SetEventCenterManager(tEventCenterManager *pEventCenterManager)
		{
			AssertEx(0, "Error : use not finish function on call setEventCenterManager()."); 
		}
		virtual tEventCenterManager* GetEventCenterManager(void){ return NULL;; }

        virtual void Dump(void);
        virtual void Log(const char *szInfo, ...);

	public:
         virtual AutoEvent _Start(ushort eventID, int eventNameIndex);

		 virtual void AppendListen(const char *szListenEventName, EventCallBack  listenCall, bool bCheckExist = false);

		 virtual bool RemoveListen(const char *szListenEventName, EventCallBack  listenCall);

		 virtual void DispatchEvent(tEvent *triggerEvent);

	protected:
		EventFactoryMap				mFactoryMap;
		EasyHash<int, AutoEventFactory>	mFactoryArray;
		Array<AutoEventFactory>		mArrayIndex;
		int							mEnvironmentID;		
		
		FixedTimeManager			*mFixedTimeManager;
		AutoPtr<NodePool>				mShareListPool;

		PoolLoop<AutoEvent>			mEventList;		

		PoolLoop<AutoEvent>			mFreeEventList;

		bool						mbUseIDIndexData;
		bool						mbNeedGenerateIndex;
		bool						mbNowProcessing;
		bool						mbCheckOptimizeSpeed;
		DataBuffer					mMsgIndexData;

	public:
		AutoEventFactory			mResponseEventFactory;
        DataProtocol                    mProtocolMgr;

		typedef EasyList<EventCallBack>	ListenCallList;
		typedef AutoPtr<ListenCallList> AListenCallList;
		EasyHash<AString, AListenCallList>	mListenCallHash;
		AutoPtr<NodePool>							mEventPool;
		AObjectPtr											mOwnerPtr;
	};
	//-----------------------------------------------------------------------------------
}
//-----------------------------------------------------------------------------------

#ifndef __LINUX__
template<>
void Hand<Logic::tEventCenter>::FreeClass( Logic::tEventCenter *p )
{
	p->Release();
}


//-----------------------------------------------------------------------------------

template<>
void Hand<Logic::tEventCenter>::FreeUse()
{
	mUse->Release();
}

#endif


typedef Hand<Logic::tEventCenter> AutoEventCenter;
//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
namespace Logic
{
	class EventCoreDll_Export EventCenter : public Logic::tEventCenter
	{
	public:
		EventCenter();

		virtual void _SetNetTool(int nType, AutoNet netTool);;
		virtual AutoNet _GetNetTool(int nType){ return mNet; }

	public:
		//virtual bool SendEvent(AutoEvent &event, int nNetType = 0, int nTarget = 0);

		AutoEvent StartDefaultEvent( const char* eventName );

		AutoEventFactory RegisterDefaultEvent( const char* szEventName );

		virtual KEY_TYPE AutoAlloctKey(){ return mAutoKeyTool.AlloctKey(); }
		

	protected:
		Hand<tNetHandle>	mNet;
		AutoKey				mAutoKeyTool;


	};

}
//----------------------------------------------------------------------

#endif  //_TEVENTCENTER_H
