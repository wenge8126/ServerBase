//-------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : tEventFactory.cpp
//  @ Date : 2011-5-18
//  @ Author : 杨文鸽
// 事件驱动系统
//-------------------------------------------------------------------

#include "EventFactory.h"
#include "Event.h"
#include "CEvent.h"
#include "EventCenter.h"
#include "Common.h"
#include "TimeManager.h"

namespace Logic
{
	//-------------------------------------------------------------------
	//-------------------------------------------------------------------	
	tEventFactory::tEventFactory()
		: mID(0)
	{
#if SHOW_EVENT_TICK
		mCount = 0;
		mAverageTick = 0;
#endif
	}	
	//-------------------------------------------------------------------
	tEventFactory::~tEventFactory()
	{
		OnRemove();
	}
	//-------------------------------------------------------------------
	
	void tEventFactory::Release(){ delete this; }

	// 在强制释放之间, 先把自己生产所有事件强制释放, 一般是事件中心要求全部释放
	void tEventFactory::OnForceFreeBefore()
	{
		for (auto it = mAllEventList.begin(); it; ++it)
		{
			(*it)->GetSelf()._free();
		}
		mAllEventList.clear();
	}

	//-------------------------------------------------------------------

	void tEventFactory::FreeEvent( tEvent *event )
	{
		for (auto it =mAllEventList.begin(); it; ++it)
		{
			if ((*it) == event)
			{
				mAllEventList.erase(it);
				break;
			}
		}

#if OPTIMIZE_MODE
		if (HasState(eReleased))
		{
			delete event;
			return;
		}
		if (mFreeEventPool.size()>FREE_EVENT_MAX_COUNT)
		{
			delete event;
			return;
		}
		BaseEvent *pEvt = dynamic_cast<BaseEvent*>(event);
		if (pEvt!=NULL)
			pEvt->initData();		
		//AssertEx(!event->getFinished(), "[%s]事件未正确初始数据", event->GetEventName());
		event->SetFactory(AutoEventFactory());
#if DEVELOP_MODE
		AssertEx(!event->mbNowFree, "严重错误，[%s]事件当前应该为释放状态", event->GetEventName());
		event->mbNowFree = true;
#endif
		mFreeEventPool.push(event);
#else
		delete event;
		return;
#endif
	}
	//-------------------------------------------------------------------
	AutoEvent tEventFactory::StartEvent( void )
	{		
		AutoEvent hEvent = mFreeEventPool.pop();
		if (hEvent)
		{
			hEvent->SetFactory(GetSelf());
			mAllEventList.insert(hEvent.getPtr());
#if DEVELOP_MODE
			AssertEx(hEvent->mbNowFree, "严重错误，[%s]事件当前应该为释放状态", GetEventName());
			hEvent->mbNowFree = false;
#endif

#if USE_SAFT_RELEASE_EVENT
			hEvent->initData();		
#endif
			//AssertEx(!hEvent->getFinished(), "[%s]事件未正确初始数据", hEvent->GetEventName());
#if SAVE_DEBUG_INFO			
			hEvent->mCode = tEvent::gCode++;
#endif

#if SHOW_EVENT_TICK
			mStartTick = TimeManager::NowTick();
			mCount ++;
#endif
			return hEvent;
		}
		//if (!mBaseEvent)
		//{
		//	mBaseEvent = NewEvent();
		//	hEvent = mBaseEvent;
		//}
		//else if (mBaseEvent.getUseCount()==1)
		//{
		//	mBaseEvent->InitData();
		//	return mBaseEvent;
		//}
		//else
			hEvent = NewEvent();

#if DEVELOP_MODE
			hEvent->mName = mEventName;
#endif
		//hEvent->__SetSelfHandle(hEvent);
		hEvent->SetFactory(mSelf);

		// 需要时可使用事件的 Wait();
		//_OnWaitEvent(hEvent);

		// init data append to event, for client use
		//hEvent->AppendData( GetData(), true );

		//hEvent->GetData().setName(hEvent->GetEventNameInfo()); 
		mAllEventList.insert(hEvent.getPtr());
		return hEvent;
	}

	void tEventFactory::SetEventName( const char* strEventName )
	{
		mEventName = strEventName; 
		mNameIndex = MAKE_INDEX_ID(mEventName.c_str());
		//INFO_LOG(" [%d] = %s ", mNameIndex, strEventName);
	}

	bool tEventFactory::SaveEventName( DataStream *destData )
	{
		return destData->writeString(GetEventName());
	}

	bool tEventFactory::SaveEventNameIndex( DataStream *destData )
	{
		return destData->write(GetNameIndex());
	}

	void tEventFactory::OnRemove()
	{
		while (true)
		{
			tEvent *p = mFreeEventPool.pop();
			if (p!=NULL)
				delete p;
			else
				break;
		}
	}

	//-------------------------------------------------------------------
	//-------------------------------------------------------------------	
	CEventFactory::CEventFactory() 
		: mNeedRemove(false)
	{

	}

	//-------------------------------------------------------------------

	CEventFactory::~CEventFactory()
	{

	}
	//-------------------------------------------------------------------
	void CEventFactory::ReaydyListNodePool( AutoPtr<NodePool> hPool)
	{
		mTriggerEventList.ReadyNodePool(hPool);
		mAllEventList.ReadyNodePool(GetEventCenter()->mEventPool);
	}
	//-------------------------------------------------------------------
	void CEventFactory::Initialize( void )
	{
		for(EventList::iterator it=mTriggerEventList.begin(); it; ++it)
		{
			(*it)._free();
		}
		mTriggerEventList.clear();
	}
	//-------------------------------------------------------------------

	void CEventFactory::_OnWaitEvent(AutoEvent hEvent) 
	{
		if (!_NeedWaitTrigger())
			return;
		// 先查寻一下是否已经加入
		if (!mTriggerEventList.empty())
		{
			for(EventList::iterator it=mTriggerEventList.begin(); it; ++it)
			{
				if ( (*it)==hEvent )
					return;
			}
		}
		mTriggerEventList.insert(hEvent);
	}
	//-------------------------------------------------------------------

	void  CEventFactory::RemoveTriggerEvent(AutoEvent &event)
	{
		mTriggerEventList.remove(event);
	}
	//-------------------------------------------------------------------

	bool  CEventFactory::_HasRelation(AutoEvent &hEvent) 
	{
		if (mTriggerEventNameMap.empty())
			return false;
		
		return mTriggerEventNameMap.exist(hEvent->GetNameIndex());
		//return _ExistTriggerEventList(hEvent->GetEventName());
	}
	//-------------------------------------------------------------------

	void CEventFactory::_OnEvent(AutoEvent &hEvent)
	{
#if SHOW_EVENT_TICK
		UInt64 tickDiff = TimeManager::NowTick() - mStartTick;
		if (tickDiff >= 0 && mCount > 0)
		{
			UInt64 totalTime = mAverageTick * (mCount - 1) + tickDiff;
			mAverageTick = (int)(totalTime / mCount);
		}
#endif
		if (mTriggerEventList.empty()) 
			return;
		for( EventList::iterator it=mTriggerEventList.begin(); it; ++it )
		{
			if (!(*it)->getFinished())
			{
				(*it)->_OnEvent(hEvent);						
			}
		}
	}
	//-------------------------------------------------------------------

	void CEventFactory::_NodifyEventFinish(AutoEvent hEvent)
	{
		// 这里不能直接从mTriggerEventList里删除，因为可能正在mTriggerEventList内迭代循环处理
		mNeedRemove = true;
	}
	//-------------------------------------------------------------------

	void CEventFactory::AppendTriggerEventName( const char* strEventName )
	{
		int key = MAKE_INDEX_ID(strEventName);
		if (!mTriggerEventNameMap.exist(key))
		{
			mTriggerEventNameMap.insert(key, strEventName);
		}
	}
	//-------------------------------------------------------------------

	void CEventFactory::RemoveTriggerEventName( const char* strEventName )
	{
		int key = MAKE_INDEX_ID(strEventName);
		mTriggerEventNameMap.erase(key);
	}
	//-------------------------------------------------------------------

	bool CEventFactory::_ExistTriggerEventList(const char* eventName)
	{
		return mTriggerEventNameMap.exist(MAKE_INDEX_ID(eventName));
	}
	//-------------------------------------------------------------------

	void CEventFactory::Process( void *param )
	{
		// NOTE:事件释放已经由中心进行处理, setDestory后, 在事件中心内进行检查并完全释放
		// 处理杀死已经死亡的事件, 目的是解决事件死锁后不能自动释放问题

	}
	//-------------------------------------------------------------------

	AutoTable CEventFactory::GetConfigTable( void ) const
	{
		AutoTable hTable;
		mConfigData.get("CONFIG", hTable);
		if (!hTable)
		{
			hTable = tBaseTable::NewBaseTable();
			mConfigData.set("CONFIG", hTable);
		}
		return hTable;
	}
	//-------------------------------------------------------------------

	void CEventFactory::SetConfigTable( AutoTable hTable )
	{
		mConfigData.set("CONFIG", hTable);
	}

	//-------------------------------------------------------------------
	// 使用帮助信息表格, 此表格内保存事件的使用说明及使用到的数据名称,类型,说明等详细信息
	// 此事件保存在工厂实例中,用于开发时指导使用,物理保存与数据库中,以便多客户同时编辑
	/*	+------------------------------------------------------------------------------+
		|INT		| STRING	| STRING	|  STRING	|	STRING						|
		+------------------------------------------------------------------------------+
		|索引		| 数据名称	| 数据类型	|	描述	|	备注						|
		+------------------------------------------------------------------------------+
		|关系表格	|			|			|			|								|
		+------------------------------------------------------------------------------+
		|1			|SCRIPT_VALUE_NAME|STRING|脚本对象	|	由脚本中心创建,事件完成时释放|
		+------------------------------------------------------------------------------*/
	void CEventFactory::_SetHelpTable(AutoTable helpTable)
	{
		mHelpTable = helpTable;
		//mConfigData.set("__HelpTable__", helpTable);
	}
	//-------------------------------------------------------------------

	AutoTable CEventFactory::_GetHelpTable(void) const
	{
		return mHelpTable;
		//AutoTable hTable;
		//mConfigData.get("__HelpTable__", hTable);
		//if (!hTable)
		//{
		//	hTable = MEM_NEW NiceTable();
		//	mConfigData.set("CONFIG", hTable);
		//}
		//return hTable;
	}



	//-------------------------------------------------------------------

}

