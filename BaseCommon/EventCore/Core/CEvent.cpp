//-------------------------------------------------------------------
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : BaseEvent.cpp
//  @ Date : 2011-5-18
//  @ Author : 杨文鸽
// 事件驱动系统
//-------------------------------------------------------------------

#include <stdarg.h>
#include "CEvent.h"

#include "EventFactory.h"
#include "EventCenter.h"

#include "AutoString.h"

#include "FieldTypeDefine.h"


//-------------------------------------------------------------------

//-------------------------------------------------------------------

namespace Logic
{
	//-------------------------------------------------------------------
	//-------------------------------------------------------------------
	BaseEvent::BaseEvent() 
		: mEventFactory(NULL)
		, mUpdateInfo(NULL)
		, mUseData(NULL)
	{
		
	}
	//-------------------------------------------------------------------

	BaseEvent::~BaseEvent()
	{
	}
	//-------------------------------------------------------------------

	void BaseEvent::SetFactory(AutoEventFactory hFactory) 
	{
		mEventFactory = hFactory;
	}
	//-------------------------------------------------------------------


	tEventCenter* BaseEvent::GetEventCenter( void )const
	{
		if (mEventFactory)
			return mEventFactory->GetEventCenter();
		else
			return NULL;
	}

	void BaseEvent::Wait()
	{
		AssertEx(0, "此功能禁止使用! 保留中");
		//mEventFactory->_OnWaitEvent(mSelf);
	}

	AutoEvent BaseEvent::StartEvent(const char* eventName)
	{
		AutoEvent hEvent = GetEventCenter()->StartEvent(eventName);
		//if (hEvent)
		//	hEvent->DoEvent(false);
		return hEvent;
	}

	AutoEvent BaseEvent::StartEvent( const char* eventName, bool bDefault )
	{
		if (bDefault)
			return GetEventCenter()->StartDefaultEvent(eventName);
		else 
			return GetEventCenter()->StartEvent(eventName);
	}

	void BaseEvent::initData( void )
	{
		InitData();
		//Log("初始清空数据");		
		
		mState.init(true);
		
		mUseData = NULL;
		mUpdateInfo = NULL;
		GetData().initData();
	}

	void BaseEvent::setFinished(bool bFinish)
	{
		if (bFinish)
			mState.open((StateDataType)STATE_EVENT_FINISH); 
		else
			mState.close((StateDataType)STATE_EVENT_FINISH);
	}

	bool BaseEvent::getFinished(void) const
	{
#if DEVELOP_MODE
		if (mbNowFree)
		{
			ERROR_LOG("使用已经释放的事件 [%s]", GetEventName());
			return true;
		}
#endif
		return !mEventFactory || mState.isOpen((StateDataType)STATE_EVENT_FINISH);
	}

	void BaseEvent::Free()
	{
		//if (bDead)
		//{
			if ( !mState.isOpen((StateDataType)STATE_EVENT_NEED_DESTORY) )
			{
				mState.open((StateDataType)STATE_EVENT_NEED_DESTORY); 
				// 加入到事件中心待处理事件列表, 中心更新时, 进行清理释放
				//GetEventCenter()->Waiting(GetSelf());

				tEventCenter *pCenter = GetEventCenter();
				if (pCenter != NULL)
					pCenter->FreeEvent(this);
				else
					delete this;
			}
		//}
		//else
		//	mState.close((StateDataType)STATE_EVENT_NEED_DESTORY);
	}


	const char* BaseEvent::GetEventName( void ) const
	{
		if (mEventFactory)
			return mEventFactory->GetEventName();

		return "ErrorNone";
	}

	void BaseEvent::_NodifyEventFinish()
	{
		GetEventCenter()->_NodifyEventFinish(mSelf);
	}


	//-------------------------------------------------------------------
    enum EVENT_NICE_DATA_PROTOCAL
    {
        eEventSaveDefault,
        eEventSaveByProtocal,
        eEventSaveAndProtocal,
    };

	bool BaseEvent::_Serialize( DataStream *destData )
	{
#if _USE_NICE_PROTOCOL_
        if (hasState(STATE_EVENT_USE_PROTOCOL_SAVE))
        {
            AutoEventFactory f = GetEventFactory();
            if (hasState(STATE_EVENT_NEED_SAVE_PROTOCOL))
            {
                if (!f->mNiceProtocol)
                {
                    f->mNiceProtocol = GetEventCenter()->mProtocolMgr.GenerateProtocol(dynamic_cast<NiceData*>(&GetData()), GetEventName(), true);   
                    f->mNiceProtocolData.clear(false);
                    if ( !f->mNiceProtocol || !GetEventCenter()->mProtocolMgr.SerializeProtocal(f->mNiceProtocol, &f->mNiceProtocolData))
                    {
                        f->mNiceProtocol.setNull();
                        ERROR_LOG("%s Save protocol table data fail", GetEventName());
                        return false;
                    }
#if DEVELOP_MODE
                    extern char gLogPathFile[256];
                    AString logFile = Allot::gLogPathFile;
                    logFile += "_protocol.txt";
                    GetEventCenter()->mProtocolMgr.SaveAllProtocol(logFile.c_str(), false);
#endif
                }
                if (f->mNiceProtocol)
                {
                    destData->write((byte)eEventSaveAndProtocal);
                    destData->writeData(&f->mNiceProtocolData);
                }
                else
                {
                    destData->write((byte)eEventSaveDefault);
                    return GetData().serialize(destData, false);
                }
            }
            else
            {
                AssertNote(f->mNiceProtocol, "%s Nice data protocol no exist", GetEventName());
                destData->write((byte)eEventSaveByProtocal);
            }

            return GetEventCenter()->mProtocolMgr.SaveNiceData(f->mNiceProtocol, dynamic_cast<NiceData*>(&GetData()), destData);
        }
        else
#endif 
            destData->write((byte)eEventSaveDefault);

		return GetData().serialize(destData);
	}

	bool BaseEvent::_Restore(DataStream *scrData )
	{
        byte saveState = 0;
        READ(scrData, saveState);
#if DEVELOP_MODE
         DSIZE nowSize = scrData->dataSize();
#endif
        if (saveState==eEventSaveDefault)
        {
//#if DEVELOP_MODE
//            bool bRe = GetData().restore(scrData);
//            DEBUG_LOG("*<%s> Event all nice data size %d", GetEventName(), nowSize-scrData->dataSize());
//            return bRe;
//#else
            return GetData().restore(scrData);
//#endif
        }
        AutoEventFactory f = GetEventFactory();
        if (!f)
            return false;
        if (saveState==eEventSaveAndProtocal)
        {
            f->mNiceProtocol = tBaseTable::NewBaseTable(false);
            DataBuffer temp(128);
            scrData->readData(&temp);
            temp.seek(0);
            f->mNiceProtocol = GetEventCenter()->mProtocolMgr.RestoreProtocal(&temp);
            if (!f->mNiceProtocol)
            {
                ERROR_LOG("%s Restor protocol table fail", GetEventName());
                return false;
            }
            else
            {
                //f->mNiceProtocol->SetTableName(GetEventName());
                GetEventCenter()->mProtocolMgr.AppendProtocol(f->mNiceProtocol);
#if DEVELOP_MODE
                DEBUG_LOG("<%s> Protocal data size = %d, nice data protocal data size %d", GetEventName(), temp.dataSize(), nowSize - scrData->dataSize());
                extern char gLogPathFile[256];
                AString logFile = Allot::gLogPathFile;
                logFile += "_protocol.txt";
                GetEventCenter()->mProtocolMgr.SaveAllProtocol(logFile.c_str(), false);
#endif
            }
        }
        else if (saveState!=eEventSaveByProtocal)
        {
            ERROR_LOG("%s restore save state error %d", GetEventName(), (int)saveState);
            return false;
        }
        if (!f->mNiceProtocol)
        {
            ERROR_LOG("%s restore protocal table no exist", GetEventName());
            return false;
        }

        bool bRe = GetEventCenter()->mProtocolMgr.RestoreData(f->mNiceProtocol, scrData, dynamic_cast<NiceData*>(&GetData()) );
        if (!bRe)
            ERROR_LOG("%s restore by protocal table  fail  %s", GetEventName(), f->mNiceProtocol->GetTableName())
#if DEVELOP_MODE
        else
        {
            DEBUG_LOG("<%s> Event nice data size %d", GetEventName(), nowSize-scrData->dataSize());
            NOTE_LOG(GetData().dump().c_str());
        }
#endif
		return bRe;
	}

	NICEDATA_TYPE BaseEvent::_RestoreDataType(DataStream *scrData)
	{
		byte niceType = 0;
		if (scrData->read(niceType))			
			return (NICEDATA_TYPE)niceType;
		ERROR_LOG("[%s] BaseEvent::_RestoreDataType 读取恢复数据类型失败", GetEventName());
		return NULL_NICEDATA;
	}

	bool BaseEvent::Send(int nType/* = NET_MAIN*/, int nTarget /*= 0 */)
	{
		if (nTarget==0)
		{
			AutoNet net = GetEventCenter()->_GetNetTool(nType);
			if (net)
			{
				HandConnect conn = net->GetClientConnect();
				if (conn)
					return conn->SendEvent(this);
			}
		}
		ERROR_LOG("Send fail >[%s]", GetEventName());
		return false;
		//bool b = GetEventCenter()->SendEvent(GetSelf(), nType, _getTarget());
		//Log( "→Send %s", (b ? "OK":"X"));
		//return b;
	}

	bool BaseEvent::set( const char* szKey, AutoEvent &hEvent )
	{
		return GetData().set(szKey, hEvent);
	}

	bool BaseEvent::set( const char* szKey, AutoNice &nice )
	{
		return GetData().set(szKey, nice);
	}

	bool BaseEvent::set( const char* szKey, AutoData &hData )
	{
		return GetData().set(szKey, hData);
	}

	bool BaseEvent::set( const char* szKey, ARecord &hRecord )
	{
		return GetData().set(szKey, hRecord);
	}

	bool BaseEvent::set( const char* szKey, AutoTable &hTable )
	{
		return GetData().set(szKey, hTable);
	}

	bool BaseEvent::set( const char* szKey, void *obj, const type_info &typeInfo )
	{
		return GetData().set(szKey, obj, typeInfo);
	}

	void BaseEvent::set( const char* szKey, UInt64 uVal )
	{
		GetData().set(szKey, uVal);
	}

	bool BaseEvent::get( const char* szKey, AutoNice &nice )
	{
		return GetData().get(szKey, nice);
	}

	bool BaseEvent::get( const char* szKey, AutoEvent &hEvent )
	{
		return GetData().get(szKey, hEvent);
	}

	bool BaseEvent::get( const char* szKey, AutoData &hData )
	{
		return GetData().get(szKey, hData);
	}

	bool BaseEvent::get( const char* szKey, ARecord &hRecord )
	{
		return GetData().get(szKey, hRecord);
	}

	bool BaseEvent::get( const char* szKey, AutoTable &hTable )
	{
		return GetData().get(szKey, hTable);
	}

	bool BaseEvent::get( const char* szKey, void *obj, const type_info &typeInfo )
	{
		return GetData().get(szKey, obj, typeInfo);
	}

	Data BaseEvent::get( const char* szKey, const char *throwInfo /*= NULL*/ ) const
	{
		Data val = GetData().get(szKey);
		if (val.empty() && throwInfo)
		{
			AssertEx(0, throwInfo);
#ifndef __LINUX__
			AString info = "Error: no exist [";
			info += szKey;
			info += "], info --> ";
			info += throwInfo;

			throw std::exception(info.c_str());
#else
            throw 1;
#endif
		}
		return val;
	}

	//------------------------------------------------------------------------------

	//void* BaseEvent::_GetScriptObject( void )
	//{
	//	return GetEventCenter()->getOrMakeLuaEventObject(GetSelf());
	//	return NULL;
	//}
	////------------------------------------------------------------------------------

	//void BaseEvent::_FreeScriptObject( void )
	//{
	//	GetData().remove(SCRIPT_VALUE_NAME);
	//}

	bool BaseEvent::WaitTime( float waitTime )
	{
		return GetEventCenter()->_StartWaitTime(GetSelf(), waitTime);
	}

	void BaseEvent::_OnEventFinishNodify( AutoEvent event )
	{

	}

	size_t BaseEvent::AppendData( const tNiceData &scrData, bool bReplace )
	{
		return GetData().append(scrData, bReplace);
	}

	bool BaseEvent::_DoEvent()
	{
		//Log("Warning: run BaseEvent::_DoEvent() to Finish()");
		//Finish();
		return false;
	}

	bool BaseEvent::_OnTimeOver(void)
	{
		LOG_YELLOW;
		Log(" >>> wait over time, now finish...");
		LOG_WHITE;
		Finish(); 
		return true; 
	}

	bool BaseEvent::StartUpdate(float spaceSecond)
	{
		return GetEventCenter()->_StartUpdateEvent(GetSelf(), spaceSecond);
	}

	int BaseEvent::GetNameIndex( void )
	{
		if (mEventFactory)
			return mEventFactory->GetNameIndex();
		return 0;
	}

	//------------------------------------------------------------------------------



}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

